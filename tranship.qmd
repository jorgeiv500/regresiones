---
title: "ğŸ” ResoluciÃ³n del Problema de Transbordo"
subtitle: "ğŸ“¦ OptimizaciÃ³n de Redes con Pyomo"
author: "ğŸ‘¨â€ğŸ« Jorge IvÃ¡n Romero Gelvez"
institute: "ğŸ›ï¸ Universidad Jorge Tadeo Lozano"
date: "ğŸ“… Abril 2025"
format:
  revealjs:
    theme: simple
    slide-number: true
    highlight-style: dracula
    code-line-numbers: true
    code-annotations: hover
    mermaid:
      theme: forest
    transition: fade
    chalkboard: true
    logo: Utadeo70-fondoblanco.png
    toc: true
    toc-title: "Contenido"
    toc-depth: 2
    scrollable: true
execute:
  echo: true
  warning: false
jupyter: python3
---

## ğŸšš Â¿QuÃ© es el problema de transbordo?

- Variante del problema de transporte.
- Involucra **nodos intermedios**: el flujo pasa por depÃ³sitos o almacenes temporales.
- Ejemplo real: rutas entre fÃ¡bricas y clientes pasando por centros de distribuciÃ³n.

---

## ğŸ–¼ï¸ Diagrama de red

![Problema de transbordo](https://machinelearninggeek.com/wp-content/uploads/2022/02/image-3.png)

- FÃ¡bricas: A, B, C
- Almacenes intermedios: P, Q
- Proyectos (destinos): 1, 2, 3

---

## ğŸ“‹ Datos del problema

```python
# OrÃ­genes (fÃ¡bricas)
fabricas = ['A', 'B', 'C']
suministro = {'A': 100, 'B': 200, 'C': 200}

# Nodos intermedios (almacenes)
almacenes = ['P', 'Q']

# Destinos (proyectos)
proyectos = ['1', '2', '3']
demanda = {'1': 50, '2': 150, '3': 300}

# Costos de fÃ¡bricas a almacenes
costos_fab_alma = {
    ('A', 'P'): 3, ('A', 'Q'): 2,
    ('B', 'P'): 4, ('B', 'Q'): 3,
    ('C', 'P'): 2.5, ('C', 'Q'): 3.5
}

# Costos de almacenes a proyectos
costos_alma_proj = {
    ('P', '1'): 2, ('P', '2'): 1, ('P', '3'): 4,
    ('Q', '1'): 3, ('Q', '2'): 2, ('Q', '3'): 5
}
```

---

## âš™ï¸ FormulaciÃ³n en Pyomo

```python
from pyomo.environ import *

model = ConcreteModel()
model.Rutas_1 = Set(initialize=[(i, j) for i in fabricas for j in almacenes])
model.Rutas_2 = Set(initialize=[(i, j) for i in almacenes for j in proyectos])

model.X1 = Var(model.Rutas_1, domain=NonNegativeReals)
model.X2 = Var(model.Rutas_2, domain=NonNegativeReals)

model.obj = Objective(
    expr=sum(costos_fab_alma[i]*model.X1[i] for i in model.Rutas_1) +
         sum(costos_alma_proj[i]*model.X2[i] for i in model.Rutas_2),
    sense=minimize
)
```

---

## ğŸ“ Restricciones del modelo

```python
# RestricciÃ³n de oferta (fÃ¡bricas)
model.oferta = ConstraintList()
for i in fabricas:
    model.oferta.add(sum(model.X1[i, j] for j in almacenes) <= suministro[i])

# RestricciÃ³n de demanda (proyectos)
model.demanda = ConstraintList()
for j in proyectos:
    model.demanda.add(sum(model.X2[i, j] for i in almacenes) >= demanda[j])

# Flujo intermedio: lo que entra a P o Q debe salir
model.flujo = ConstraintList()
for w in almacenes:
    model.flujo.add(
        sum(model.X1[i, w] for i in fabricas) ==
        sum(model.X2[w, j] for j in proyectos)
    )
```

---

## ğŸ§  Resolviendo el modelo

```python
from pyomo.opt import SolverFactory
opt = SolverFactory('glpk')
results = opt.solve(model)
model.display()
```

---

## ğŸ“Š Resultados esperados

```python
for i in model.Rutas_1:
    if model.X1[i]() > 0:
        print(f"Ruta {i} (FÃ¡brica â†’ AlmacÃ©n): {model.X1[i]():.0f}")

for i in model.Rutas_2:
    if model.X2[i]() > 0:
        print(f"Ruta {i} (AlmacÃ©n â†’ Proyecto): {model.X2[i]():.0f}")

print(f"Costo total mÃ­nimo: {model.obj():.2f}")
```

---

## ğŸ“Œ ConclusiÃ³n

- El problema de transbordo amplÃ­a el modelo clÃ¡sico de transporte.
- Pyomo permite una formulaciÃ³n flexible y clara.
- Se adapta fÃ¡cilmente a escenarios con mÃºltiples capas logÃ­sticas.
- Ideal para casos reales como hubs, bodegas, puertos, etc.

---