---
title: "ğŸ“¦ Modelos de Redes lineales: De transporte a Transbordo"
subtitle: "ğŸ”— Transporte, AsignaciÃ³n, Transbordo y Flujos Multicommodity"
author: "ğŸ‘¨â€ğŸ« Jorge IvÃ¡n Romero Gelvez"
institute: "ğŸ›ï¸ Universidad Jorge Tadeo Lozano"
date: today
format: 
  revealjs:
    theme: [default, custom.scss]
    slide-number: true
    highlight-style: dracula
    code-line-numbers: true
    code-annotations: hover
    mermaid:
      theme: forest
    transition: fade
    chalkboard: true
    logo: Utadeo70-fondoblanco.png
    toc: true
    toc-title: "Contenido"
    toc-depth: 2
    incremental: true
    scrollable: true
execute: 
  warning: false
  message: false
  echo: true
  freeze: false
jupyter: python3
---
## ğŸ¬ IntroducciÃ³n

- Muchos problemas reales pueden modelarse como redes de nodos conectados por arcos.
- Estos modelos permiten encontrar rutas Ã³ptimas, asignaciones eficientes o balances de flujo.

  - ğŸ¯ **Objetivo**: Aprender a representar y resolver modelos clÃ¡sicos de redes mediante optimizaciÃ³n.
a
---

## ğŸ§© Â¿QuÃ© es un modelo de red?

Una red dirigida incluye:

- **Nodos**: puntos donde se origina, transforma o termina el flujo.
- **Arcos**: conexiones con costos, capacidades o flujos.

  ğŸ’¡ **Ejemplo general**:
  > Distribuir unidades desde nodos origen hasta nodos destino, al menor costo.

---

## ğŸš› 1. Modelo de Transporte

**Objetivo**: Minimizar el costo de enviar unidades de varios orÃ­genes a varios destinos.

$$
\min \sum_{i=1}^{m} \sum_{j=1}^{n} c_{ij} x_{ij}
$$

Sujeto a:

- $$\sum_j x_{ij} = a_i \quad \forall i$$
- $$\sum_i x_{ij} = b_j \quad \forall j$$
- $$x_{ij} \geq 0$$

```mermaid
flowchart LR
  N1[Origen 1] -->|x11| D1[Destino 1]
  N1 -->|x12| D2[Destino 2]
  N2[Origen 2] -->|x21| D1
  N2 -->|x22| D2
```

---

## ğŸ’» CÃ³digo Pyomo: Transporte

```python
from pyomo.environ import *

model = ConcreteModel()

origenes = ['N1', 'N2']
destinos = ['D1', 'D2']
c = {('N1','D1'): 4, ('N1','D2'): 6, ('N2','D1'): 5, ('N2','D2'): 3}
a = {'N1': 30, 'N2': 40}
b = {'D1': 20, 'D2': 50}

model.x = Var(c.keys(), domain=NonNegativeReals)
model.obj = Objective(expr=sum(c[i]*model.x[i] for i in c), sense=minimize)
model.oferta = Constraint(origenes, rule=lambda m, i: sum(m.x[i,j] for j in destinos) == a[i])
model.demanda = Constraint(destinos, rule=lambda m, j: sum(m.x[i,j] for i in origenes) == b[j])
```

---

## ğŸ¯ 2. Modelo de AsignaciÃ³n

Es un caso especial del modelo de transporte donde todas las ofertas y demandas son 1.

$$
\min \sum_{i=1}^{n} \sum_{j=1}^{n} c_{ij} x_{ij}
$$

Sujeto a:

- $$\sum_j x_{ij} = 1 \quad \forall i$$
- $$\sum_i x_{ij} = 1 \quad \forall j$$
- $$x_{ij} \in \{0,1\}$$

---

## ğŸ’» Pyomo: AsignaciÃ³n Binaria

```python
trabajadores = ['E1', 'E2', 'E3']
tareas = ['T1', 'T2', 'T3']
cost = {('E1','T1'):3, ('E1','T2'):2, ('E1','T3'):4,
        ('E2','T1'):4, ('E2','T2'):3, ('E2','T3'):1,
        ('E3','T1'):5, ('E3','T2'):2, ('E3','T3'):2}

model.x = Var(cost.keys(), domain=Binary)
model.obj = Objective(expr=sum(cost[i]*model.x[i] for i in cost), sense=minimize)
model.restr1 = Constraint(trabajadores, rule=lambda m, i: sum(m.x[i,j] for j in tareas) == 1)
model.restr2 = Constraint(tareas, rule=lambda m, j: sum(m.x[i,j] for i in trabajadores) == 1)
```

---

## ğŸ” 3. Modelo de Transbordo

Permite el paso por nodos intermedios.

$$
\sum_j x_{ij} - \sum_j x_{ji} = b_i
$$

- $b_i < 0$: nodo emisor
- $b_i > 0$: nodo receptor
- $b_i = 0$: nodo de trÃ¡nsito

---

## ğŸ’» Pyomo: Transbordo

```python
nodos = ['N1','N2','N3']
arcos = [('N1','N2'),('N2','N3'),('N1','N3')]
costos = {('N1','N2'):3, ('N2','N3'):2, ('N1','N3'):5}
bi = {'N1': -60, 'N2': 0, 'N3': 60}

model.x = Var(arcos, domain=NonNegativeReals)
model.obj = Objective(expr=sum(costos[i]*model.x[i] for i in arcos), sense=minimize)
model.balances = Constraint(nodos, rule=lambda m, i:
    sum(m.x[i,j] for (ii,j) in arcos if ii == i) - sum(m.x[j,i] for (j,jj) in arcos if jj == i) == bi[i])
```

---

## ğŸ“Š MÃ©todos de ResoluciÃ³n

| MÃ©todo              | Tipo       | Ejemplo                   |
|---------------------|------------|----------------------------|
| Simplex, GLPK, CBC | Exacto     | Transporte, transbordo     |
| HÃºngaro             | Exacto     | AsignaciÃ³n binaria         |
| RamificaciÃ³n y Acot.| Exacto     | ProgramaciÃ³n entera        |
| BÃºsqueda local      | Aproximado | Vecino mÃ¡s cercano         |
| MetaheurÃ­sticas     | Aproximado | Recocido, genÃ©tico         |

---

## ğŸ“Œ IntroducciÃ³n general

- Los modelos de red permiten representar **problemas logÃ­sticos complejos** con nodos y arcos.
- Permiten decisiones Ã³ptimas en: distribuciÃ³n, asignaciÃ³n de recursos, ruteo y diseÃ±o de cadenas.

---

## ğŸš› 1. Modelo de Transporte ClÃ¡sico

- Distribuir un producto desde varios orÃ­genes a varios destinos minimizando costos.

$
\begin{aligned}
\text{Min:} & \sum_{i=1}^{m}\sum_{j=1}^{n} c_{ij} x_{ij} \\
\text{s.a.} & \sum_j x_{ij} = a_i && \text{(oferta)} \\
           & \sum_i x_{ij} = b_j && \text{(demanda)} \\
           & x_{ij} \geq 0
\end{aligned}
$

```mermaid
flowchart LR
  A1[Planta A1] -->|x11| B1[Bodega B1]
  A1 -->|x12| B2[Bodega B2]
  A2[Planta A2] -->|x21| B1
  A2 -->|x22| B2
```

---

## ğŸ§® CÃ³digo en Pyomo: Modelo de Transporte

```python
from pyomo.environ import *

model = ConcreteModel()
origenes = ['A1', 'A2']
destinos = ['B1', 'B2']
c = {('A1','B1'): 4, ('A1','B2'): 6, ('A2','B1'): 5, ('A2','B2'): 3}
a = {'A1': 30, 'A2': 40}
b = {'B1': 20, 'B2': 50}

model.x = Var(c.keys(), domain=NonNegativeReals)
model.obj = Objective(expr=sum(c[i]*model.x[i] for i in c), sense=minimize)

model.oferta = Constraint(origenes, rule=lambda m, i: sum(m.x[i,j] for j in destinos) == a[i])
model.demanda = Constraint(destinos, rule=lambda m, j: sum(m.x[i,j] for i in origenes) == b[j])
```

---

## ğŸ§® 2. Modelo de AsignaciÃ³n (lineal y mÃ©todo hÃºngaro)

- Asignar tareas a recursos con un costo mÃ­nimo.
- Es un caso especial del modelo de transporte con oferta y demanda igual a 1.

$
\begin{aligned}
\text{Min:} & \sum_{i=1}^{n} \sum_{j=1}^{n} c_{ij} x_{ij} \\
\text{s.a.} & \sum_{j} x_{ij} = 1 \quad \forall i \\
           & \sum_{i} x_{ij} = 1 \quad \forall j \\
           & x_{ij} \in \{0, 1\}
\end{aligned}
$

```mermaid
flowchart TD
  A[Trabajadores] -->|xij| B[Tareas]
```

- **MÃ©todo hÃºngaro**: Algoritmo eficiente tipo greedy-matching.

---

## ğŸ§® Pyomo para AsignaciÃ³n

```python
trabajadores = ['T1','T2','T3']
tareas = ['P1','P2','P3']
cost = {(i,j): random.randint(1,10) for i in trabajadores for j in tareas}
model.x = Var(cost.keys(), domain=Binary)

model.obj = Objective(expr=sum(cost[i]*model.x[i] for i in cost), sense=minimize)
model.restr1 = Constraint(trabajadores, rule=lambda m, i: sum(m.x[i,j] for j in tareas) == 1)
model.restr2 = Constraint(tareas, rule=lambda m, j: sum(m.x[i,j] for i in trabajadores) == 1)
```

---

## ğŸ” 3. Modelo de Transbordo

- ExtensiÃ³n del modelo de transporte permitiendo nodos intermedios.
- Se representa como un **flujo con costo mÃ­nimo** en redes.

```mermaid
flowchart LR
  O1[Origen] -->|c1| H1[Hub]
  H1 -->|c2| D1[Destino]
  O1 -->|c3| D1
```

---

## ğŸ§® Pyomo con transbordo

Usamos balance nodal:
$ \sum_j x_{ij} - \sum_j x_{ji} = b_i $

```python
nodos = ['O1','H1','D1']
arcos = [('O1','H1'),('H1','D1'),('O1','D1')]
costo = {'O1,H1': 2, 'H1,D1': 3, 'O1,D1': 5}
bi = {'O1': -50, 'H1': 0, 'D1': 50}
```

---

## ğŸ§­ 4. Soluciones Exactas vs Aproximadas

| MÃ©todo               | Tipo       | Ejemplo                 |
|----------------------|------------|--------------------------|
| PL con Solver        | Exacta     | Simplex, CBC, GLPK      |
| HÃºngaro              | Exacta     | AsignaciÃ³n binaria      |
| RamificaciÃ³n/Acot.   | Exacta     | Integer Programming     |
| BÃºsqueda local       | Aproximada | Greedy, Vecino cercano  |
| MetaheurÃ­sticas      | Aproximada | Recocido, GenÃ©tico      |

---

## ğŸ“¦ 5. Flujos Single Commodity vs Multi Commodity

- **Single commodity**: un solo tipo de producto fluye por la red.
- **Multi-commodity**: mÃºltiples productos comparten nodos y arcos.

```mermaid
flowchart LR
  S[Source] -->|Producto A| T1[Transbordo] -->|A| D1[Destino A]
  S -->|Producto B| T1 -->|B| D2[Destino B]
```

### Restricciones adicionales:
- Capacidad compartida: \( \sum_k x^k_{ij} \leq u_{ij} \)

---

## ğŸ”£ FormulaciÃ³n Multi-Commodity

$
\begin{aligned}
\min & \sum_{k} \sum_{(i,j)} c^k_{ij} x^k_{ij} \\
\text{s.a. } & \sum_j x^k_{ij} - \sum_j x^k_{ji} = b^k_i \quad \forall i,k \\
& \sum_k x^k_{ij} \leq u_{ij} \quad \forall (i,j) \\
& x^k_{ij} \geq 0
\end{aligned}
$

---

## ğŸ§® ImplementaciÃ³n Multi-commodity

```python
productos = ['A','B']
costos = {('A','O1','D1'):2, ('B','O1','D2'):3}
capacidad = {('O1','T1'):50}

model.x = Var(productos, arcos, domain=NonNegativeReals)
# Restricciones de balance y capacidad cruzada por arco
```

---

## ğŸ¯ ConclusiÃ³n General

- Los modelos de red permiten formular y resolver problemas logÃ­sticos reales.
- TÃ©cnicas como programaciÃ³n lineal y heurÃ­sticas dan flexibilidad y eficiencia.
- Pyomo + NEOS ofrece una plataforma poderosa y abierta para su resoluciÃ³n.

---

## ğŸ“š Referencias

- Hillier & Lieberman â€“ *IntroducciÃ³n a la InvestigaciÃ³n de Operaciones*.
- Taha â€“ *InvestigaciÃ³n de Operaciones*.
- Ghiani et al. â€“ *Introduction to Logistics Systems Management*.
- Pyomo Docs â€“ https://pyomo.readthedocs.io
