---
title: "ðŸ“¦ Modelos de Redes en LogÃ­stica y Operaciones"
subtitle: "ðŸ”— Transporte, AsignaciÃ³n, Transbordo y Flujos Multicommodity"
author: "ðŸ‘¨â€ðŸ« Jorge IvÃ¡n Romero Gelvez"
institute: "ðŸ›ï¸ Universidad Jorge Tadeo Lozano"
date: "ðŸ“… Abril 2025"
format: 
  revealjs:
    theme: [default, custom.scss]
    slide-number: true
    highlight-style: dracula
    code-line-numbers: true
    code-annotations: hover
    mermaid:
      theme: forest
    transition: fade
    chalkboard: true
    logo: Utadeo70-fondoblanco.png
    toc: true
    toc-title: "Contenido"
    toc-depth: 2
    incremental: true
    scrollable: true
execute: 
  warning: false
  message: false
  echo: true
  freeze: false
jupyter: python3
---

## ðŸ“Œ IntroducciÃ³n general

- Los modelos de red permiten representar **problemas logÃ­sticos complejos** con nodos y arcos.
- Permiten decisiones Ã³ptimas en: distribuciÃ³n, asignaciÃ³n de recursos, ruteo y diseÃ±o de cadenas.

---

## ðŸš› 1. Modelo de Transporte ClÃ¡sico

- Distribuir un producto desde varios orÃ­genes a varios destinos minimizando costos.

$
\begin{aligned}
\text{Min:} & \sum_{i=1}^{m}\sum_{j=1}^{n} c_{ij} x_{ij} \\
\text{s.a.} & \sum_j x_{ij} = a_i && \text{(oferta)} \\
           & \sum_i x_{ij} = b_j && \text{(demanda)} \\
           & x_{ij} \geq 0
\end{aligned}
$

```mermaid
flowchart LR
  A1[Planta A1] -->|x11| B1[Bodega B1]
  A1 -->|x12| B2[Bodega B2]
  A2[Planta A2] -->|x21| B1
  A2 -->|x22| B2
```

---

## ðŸ§® CÃ³digo en Pyomo: Modelo de Transporte

```python
from pyomo.environ import *

model = ConcreteModel()
origenes = ['A1', 'A2']
destinos = ['B1', 'B2']
c = {('A1','B1'): 4, ('A1','B2'): 6, ('A2','B1'): 5, ('A2','B2'): 3}
a = {'A1': 30, 'A2': 40}
b = {'B1': 20, 'B2': 50}

model.x = Var(c.keys(), domain=NonNegativeReals)
model.obj = Objective(expr=sum(c[i]*model.x[i] for i in c), sense=minimize)

model.oferta = Constraint(origenes, rule=lambda m, i: sum(m.x[i,j] for j in destinos) == a[i])
model.demanda = Constraint(destinos, rule=lambda m, j: sum(m.x[i,j] for i in origenes) == b[j])
```

---

## ðŸ§® 2. Modelo de AsignaciÃ³n (lineal y mÃ©todo hÃºngaro)

- Asignar tareas a recursos con un costo mÃ­nimo.
- Es un caso especial del modelo de transporte con oferta y demanda igual a 1.

$
\begin{aligned}
\text{Min:} & \sum_{i=1}^{n} \sum_{j=1}^{n} c_{ij} x_{ij} \\
\text{s.a.} & \sum_{j} x_{ij} = 1 \quad \forall i \\
           & \sum_{i} x_{ij} = 1 \quad \forall j \\
           & x_{ij} \in \{0, 1\}
\end{aligned}
$

```mermaid
flowchart TD
  A[Trabajadores] -->|xij| B[Tareas]
```

- **MÃ©todo hÃºngaro**: Algoritmo eficiente tipo greedy-matching.

---

## ðŸ§® Pyomo para AsignaciÃ³n

```python
trabajadores = ['T1','T2','T3']
tareas = ['P1','P2','P3']
cost = {(i,j): random.randint(1,10) for i in trabajadores for j in tareas}
model.x = Var(cost.keys(), domain=Binary)

model.obj = Objective(expr=sum(cost[i]*model.x[i] for i in cost), sense=minimize)
model.restr1 = Constraint(trabajadores, rule=lambda m, i: sum(m.x[i,j] for j in tareas) == 1)
model.restr2 = Constraint(tareas, rule=lambda m, j: sum(m.x[i,j] for i in trabajadores) == 1)
```

---

## ðŸ” 3. Modelo de Transbordo

- ExtensiÃ³n del modelo de transporte permitiendo nodos intermedios.
- Se representa como un **flujo con costo mÃ­nimo** en redes.

```mermaid
flowchart LR
  O1[Origen] -->|c1| H1[Hub]
  H1 -->|c2| D1[Destino]
  O1 -->|c3| D1
```

---

## ðŸ§® Pyomo con transbordo

Usamos balance nodal:
$ \sum_j x_{ij} - \sum_j x_{ji} = b_i $

```python
nodos = ['O1','H1','D1']
arcos = [('O1','H1'),('H1','D1'),('O1','D1')]
costo = {'O1,H1': 2, 'H1,D1': 3, 'O1,D1': 5}
bi = {'O1': -50, 'H1': 0, 'D1': 50}
```

---

## ðŸ§­ 4. Soluciones Exactas vs Aproximadas

| MÃ©todo               | Tipo       | Ejemplo                 |
|----------------------|------------|--------------------------|
| PL con Solver        | Exacta     | Simplex, CBC, GLPK      |
| HÃºngaro              | Exacta     | AsignaciÃ³n binaria      |
| RamificaciÃ³n/Acot.   | Exacta     | Integer Programming     |
| BÃºsqueda local       | Aproximada | Greedy, Vecino cercano  |
| MetaheurÃ­sticas      | Aproximada | Recocido, GenÃ©tico      |

---

## ðŸ“¦ 5. Flujos Single Commodity vs Multi Commodity

- **Single commodity**: un solo tipo de producto fluye por la red.
- **Multi-commodity**: mÃºltiples productos comparten nodos y arcos.

```mermaid
flowchart LR
  S[Source] -->|Producto A| T1[Transbordo] -->|A| D1[Destino A]
  S -->|Producto B| T1 -->|B| D2[Destino B]
```

### Restricciones adicionales:
- Capacidad compartida: \( \sum_k x^k_{ij} \leq u_{ij} \)

---

## ðŸ”£ FormulaciÃ³n Multi-Commodity

$
\begin{aligned}
\min & \sum_{k} \sum_{(i,j)} c^k_{ij} x^k_{ij} \\
\text{s.a. } & \sum_j x^k_{ij} - \sum_j x^k_{ji} = b^k_i \quad \forall i,k \\
& \sum_k x^k_{ij} \leq u_{ij} \quad \forall (i,j) \\
& x^k_{ij} \geq 0
\end{aligned}
$

---

## ðŸ§® ImplementaciÃ³n Multi-commodity

```python
productos = ['A','B']
costos = {('A','O1','D1'):2, ('B','O1','D2'):3}
capacidad = {('O1','T1'):50}

model.x = Var(productos, arcos, domain=NonNegativeReals)
# Restricciones de balance y capacidad cruzada por arco
```

---

## ðŸŽ¯ ConclusiÃ³n General

- Los modelos de red permiten formular y resolver problemas logÃ­sticos reales.
- TÃ©cnicas como programaciÃ³n lineal y heurÃ­sticas dan flexibilidad y eficiencia.
- Pyomo + NEOS ofrece una plataforma poderosa y abierta para su resoluciÃ³n.

---

## ðŸ“š Referencias

- Hillier & Lieberman â€“ *IntroducciÃ³n a la InvestigaciÃ³n de Operaciones*.
- Taha â€“ *InvestigaciÃ³n de Operaciones*.
- Ghiani et al. â€“ *Introduction to Logistics Systems Management*.
- Pyomo Docs â€“ https://pyomo.readthedocs.io
